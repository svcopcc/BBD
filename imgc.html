<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‰πùÂÆÆÊ†ºË£ΩÂúñÊ©üÂô®‰∫∫</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        .container {
            max-width: 100%;
            overflow-x: hidden;
            padding: 1rem;
        }
        canvas {
            border: 2px solid #e5e7eb;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            background-color: #f9fafb;
            touch-action: none; /* Èò≤Ê≠¢Âú®Áï´Â∏É‰∏äÊªëÂãïÊôÇËß∏ÁôºÁÄèË¶ΩÂô®Ë°åÁÇ∫ */
        }
        .hover-effect {
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .hover-effect:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.15);
        }
        .preview-image-container {
            position: relative;
        }
        .delete-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            background-color: #ef4444;
            color: white;
            border-radius: 9999px;
            width: 24px;
            height: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 1rem;
            line-height: 1;
            padding: 0;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: background-color 0.2s;
        }
        .delete-btn:hover {
            background-color: #dc2626;
        }
        input[type="radio"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            display: inline-block;
            width: 1.5rem;
            height: 1.5rem;
            border-radius: 50%;
            border: 2px solid #cbd5e1;
            background-color: #fff;
            cursor: pointer;
            position: relative;
            top: 4px;
        }
        input[type="radio"]:checked {
            border-color: #3b82f6;
            background-color: #3b82f6;
        }
        input[type="radio"]:checked::after {
            content: '';
            display: block;
            width: 0.75rem;
            height: 0.75rem;
            border-radius: 50%;
            background-color: white;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        input[type="checkbox"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            display: inline-block;
            width: 1.5rem;
            height: 1.5rem;
            border: 2px solid #cbd5e1;
            background-color: #fff;
            border-radius: 0.25rem;
            cursor: pointer;
            position: relative;
            top: 4px;
        }
        input[type="checkbox"]:checked {
            border-color: #3b82f6;
            background-color: #3b82f6;
        }
        input[type="checkbox"]:checked::after {
            content: '‚úì';
            color: white;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1rem;
        }
        .paste-btn {
            @apply flex items-center justify-center p-2 rounded-md bg-gray-200 text-gray-700 hover:bg-gray-300 transition-colors;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">

    <div class="container mx-auto p-4 md:p-8">
        <h1 class="text-3xl md:text-4xl font-bold text-center text-blue-600 mb-6">‰πùÂÆÆÊ†ºË£ΩÂúñÊ©üÂô®‰∫∫</h1>
        <p class="text-center text-gray-600 mb-8">‰∏äÂÇ≥ÊÇ®ÁöÑÁÖßÁâá‰∏¶Ë®≠ÂÆöÊñáÂ≠óÔºå‰æÜË£Ω‰Ωú‰∏ÄÂºµÁç®ÁâπÁöÑ‰πùÂÆÆÊ†ºÂúñÁâáÔºÅ</p>
        
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 lg:gap-12 mb-8">
            <!-- CanvasÂçÄÂüü -->
            <div class="lg:order-2 flex justify-center items-center p-2 rounded-xl bg-white shadow-lg border border-gray-200">
                <canvas id="gridCanvas" width="1108" height="1477" class="w-full h-auto rounded-lg"></canvas>
            </div>

            <!-- ÊéßÂà∂Èù¢Êùø -->
            <div class="lg:order-1 p-6 rounded-xl bg-white shadow-lg border border-gray-200">
                <div class="space-y-6">
                    
                    <!-- ÁÖßÁâá‰∏äÂÇ≥ -->
                    <div>
                        <h2 class="text-xl font-semibold mb-2 text-gray-700">1. ‰∏äÂÇ≥ÁÖßÁâá (ÊúÄÂ§ö8Âºµ)</h2>
                        <label for="imageUpload" class="block w-full text-center py-3 px-6 bg-blue-500 text-white rounded-full cursor-pointer hover-effect">
                            ÈÅ∏ÊìáÁÖßÁâá
                        </label>
                        <input type="file" id="imageUpload" class="hidden" multiple accept="image/*">
                        <div id="previewContainer" class="flex flex-wrap gap-4 mt-4"></div>
                    </div>

                    <!-- ÊñáÂ≠óÊ†ºÂ≠êË®≠ÂÆö -->
                    <div>
                        <h2 class="text-xl font-semibold mb-2 text-gray-700">2. Ë®≠ÂÆöÊñáÂ≠óÊ†º</h2>
                        <div class="grid grid-cols-3 gap-2 text-center text-sm">
                            <label class="p-2 border border-gray-300 rounded-md cursor-pointer hover:bg-gray-100 transition-colors">
                                <input type="radio" name="textPosition" value="0" class="mr-1"> 1
                            </label>
                            <label class="p-2 border border-gray-300 rounded-md cursor-pointer hover:bg-gray-100 transition-colors">
                                <input type="radio" name="textPosition" value="1" class="mr-1"> 2
                            </label>
                            <label class="p-2 border border-gray-300 rounded-md cursor-pointer hover:bg-gray-100 transition-colors">
                                <input type="radio" name="textPosition" value="2" class="mr-1"> 3
                            </label>
                            <label class="p-2 border border-gray-300 rounded-md cursor-pointer hover:bg-gray-100 transition-colors">
                                <input type="radio" name="textPosition" value="3" class="mr-1"> 4
                            </label>
                            <label class="p-2 border border-gray-300 rounded-md cursor-pointer hover:bg-gray-100 transition-colors">
                                <input type="radio" name="textPosition" value="4" class="mr-1"> 5
                            </label>
                            <label class="p-2 border border-gray-300 rounded-md cursor-pointer hover:bg-gray-100 transition-colors">
                                <input type="radio" name="textPosition" value="5" class="mr-1"> 6
                            </label>
                            <label class="p-2 border border-gray-300 rounded-md cursor-pointer hover:bg-gray-100 transition-colors">
                                <input type="radio" name="textPosition" value="6" class="mr-1"> 7
                            </label>
                            <label class="p-2 border border-gray-300 rounded-md cursor-pointer hover:bg-gray-100 transition-colors">
                                <input type="radio" name="textPosition" value="7" class="mr-1"> 8
                            </label>
                            <label class="p-2 border border-gray-300 rounded-md cursor-pointer hover:bg-gray-100 transition-colors">
                                <input type="radio" name="textPosition" value="8" class="mr-1" checked> 9
                            </label>
                        </div>
                    </div>

                    <!-- ÊñáÂ≠óÂÖßÂÆπË®≠ÂÆö -->
                    <div>
                        <h2 class="text-xl font-semibold mb-2 text-gray-700">3. Ë®≠ÂÆöÊñáÂ≠óÂÖßÂÆπ</h2>
                        <div class="space-y-4">
                            <!-- Á¨¨‰∏ÄÂàó -->
                            <div>
                                <label for="textLine1" class="block text-sm font-medium text-gray-600">Á¨¨‰∏ÄÂàó</label>
                                <div class="flex items-center space-x-2 mt-1">
                                    <input type="text" id="textLine1" placeholder="Ë´ãËº∏ÂÖ•Á¨¨‰∏ÄÂàóÊñáÂ≠ó" class="block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50">
                                    <button id="pasteButton" class="paste-btn">üìã</button>
                                </div>
                            </div>
                            <!-- Á¨¨‰∫åÂàó -->
                            <div>
                                <label class="block text-sm font-medium text-gray-600">Á¨¨‰∫åÂàó</label>
                                <div class="flex items-center space-x-2 mt-1">
                                    <input type="checkbox" id="checkboxLine2">
                                    <label for="checkboxLine2" class="text-sm">ÊãâÁ∑öÈêµÂ°î‰øùÈ§ä</label>
                                </div>
                                <input type="text" id="textLine2" placeholder="ÊàñËá™Ë°åËº∏ÂÖ•ÊñáÂ≠ó" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50">
                            </div>
                            <!-- Á¨¨‰∏âÂàó -->
                            <div>
                                <label class="block text-sm font-medium text-gray-600">Á¨¨‰∏âÂàó</label>
                                <div class="flex items-center space-x-2 mt-1">
                                    <input type="checkbox" id="checkboxLine3">
                                    <label for="checkboxLine3" class="text-sm">‰ªäÊó•</label>
                                </div>
                                <input type="date" id="datePicker" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- ÂåØÂá∫ÊåâÈàï -->
                <button id="exportButton" class="w-full py-3 px-6 mt-8 text-white font-bold bg-green-500 rounded-full hover-effect focus:outline-none focus:ring-2 focus:ring-green-300 focus:ring-offset-2">
                    ÂåØÂá∫ÊàêÂúñÁâá
                </button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gridCanvas');
        const ctx = canvas.getContext('2d');
        const imageUpload = document.getElementById('imageUpload');
        const textPositionRadios = document.getElementsByName('textPosition');
        const textLine1Input = document.getElementById('textLine1');
        const checkboxLine2 = document.getElementById('checkboxLine2');
        const textLine2Input = document.getElementById('textLine2');
        const checkboxLine3 = document.getElementById('checkboxLine3');
        const datePicker = document.getElementById('datePicker');
        const exportButton = document.getElementById('exportButton');
        const pasteButton = document.getElementById('pasteButton');
        const previewContainer = document.getElementById('previewContainer');

        const CANVAS_WIDTH = 1108;
        const CANVAS_HEIGHT = 1477;
        const BORDER_RADIUS = 20;
        const BORDER_WIDTH = 20;

        let uploadedImages = [];
        let textCellPosition = 8;
        let isDragging = false;
        let draggedItemIndex = -1;
        let lastX = 0;
        let lastY = 0;
        let gridLayout = {};

        function getGridLayout(itemCount) {
            if (itemCount <= 0) return { rows: 1, cols: 1 };
            if (itemCount === 1) return { rows: 1, cols: 1 };
            if (itemCount === 2) return { rows: 2, cols: 1 };
            if (itemCount === 3) return { rows: 3, cols: 1 };
            if (itemCount === 4) return { rows: 2, cols: 2 };
            if (itemCount <= 6) return { rows: 3, cols: 2 };
            if (itemCount <= 8) return { rows: 4, cols: 2 };
            return { rows: 3, cols: 3 };
        }

        function drawRoundedRect(x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        function drawImageWithBorder(imageData, x, y, width, height) {
            const { image, offsetX, offsetY } = imageData;

            ctx.fillStyle = 'white';
            drawRoundedRect(x, y, width, height, BORDER_RADIUS);
            ctx.fill();

            const innerX = x + BORDER_WIDTH;
            const innerY = y + BORDER_WIDTH;
            const innerWidth = width - BORDER_WIDTH * 2;
            const innerHeight = height - BORDER_WIDTH * 2;

            const imageAspectRatio = image.width / image.height;
            const cellAspectRatio = innerWidth / innerHeight;

            let sourceX = 0;
            let sourceY = 0;
            let sourceWidth = image.width;
            let sourceHeight = image.height;

            if (imageAspectRatio > cellAspectRatio) {
                sourceHeight = image.height;
                sourceWidth = image.height * cellAspectRatio;
                sourceX = (image.width - sourceWidth) / 2 - offsetX;
            } else {
                sourceWidth = image.width;
                sourceHeight = image.width / cellAspectRatio;
                sourceY = (image.height - sourceHeight) / 2 - offsetY;
            }

            ctx.save();
            drawRoundedRect(innerX, innerY, innerWidth, innerHeight, BORDER_RADIUS / 2);
            ctx.clip();
            ctx.drawImage(image, sourceX, sourceY, sourceWidth, sourceHeight, innerX, innerY, innerWidth, innerHeight);
            ctx.restore();
        }

        function drawTextCell(text, x, y, width, height) {
            // Áπ™Ë£ΩËÉåÊôØ
            ctx.fillStyle = 'white';
            ctx.fillRect(x, y, width, height);
            
            ctx.fillStyle = '#f9fafb';
            drawRoundedRect(x + BORDER_WIDTH, y + BORDER_WIDTH, width - BORDER_WIDTH * 2, height - BORDER_WIDTH * 2, BORDER_RADIUS / 2);
            ctx.fill();

            const innerX = x + BORDER_WIDTH;
            const innerY = y + BORDER_WIDTH;
            const innerWidth = width - BORDER_WIDTH * 2;
            const innerHeight = height - BORDER_WIDTH * 2;
            const lines = text.split('\n');
            
            ctx.fillStyle = '#1f2937';
            ctx.textAlign = 'center';

            // --- Áπ™Ë£ΩÁ¨¨‰∏ÄÂàóÊñáÂ≠ó ---
            const mainLine = lines[0] || '';
            let mainFontSize = innerHeight; 
            do {
                mainFontSize--;
                ctx.font = `bold ${mainFontSize}px Arial, sans-serif`;
            } while (ctx.measureText(mainLine).width > innerWidth || mainFontSize * 1.2 > innerHeight * 0.7);

            const mainLineHeight = mainFontSize * 1.2;
            
            // --- Áπ™Ë£ΩÁ¨¨‰∫å„ÄÅ‰∏âÂàóÊñáÂ≠ó ---
            const smallFontSize = 48; // Âõ∫ÂÆöÂ≠óÈ´îÂ§ßÂ∞è
            ctx.font = `${smallFontSize}px Arial, sans-serif`;
            const smallLineHeight = smallFontSize * 1.2;
            
            const totalHeight = mainLineHeight + (lines.length > 1 ? smallLineHeight : 0) + (lines.length > 2 ? smallLineHeight : 0);
            const startY = innerY + (innerHeight - totalHeight) / 2;

            // Áπ™Ë£ΩÁ¨¨‰∏ÄÂàó
            ctx.textBaseline = 'middle';
            ctx.font = `bold ${mainFontSize}px Arial, sans-serif`;
            ctx.fillText(mainLine, innerX + innerWidth / 2, startY + mainLineHeight / 2);

            // Áπ™Ë£ΩÁ¨¨‰∫å„ÄÅ‰∏âÂàó
            ctx.font = `${smallFontSize}px Arial, sans-serif`;
            if (lines.length > 1) {
                ctx.fillText(lines[1], innerX + innerWidth / 2, startY + mainLineHeight + smallLineHeight / 2);
            }
            if (lines.length > 2) {
                ctx.fillText(lines[2], innerX + innerWidth / 2, startY + mainLineHeight + smallLineHeight + smallLineHeight / 2);
            }
        }

        async function drawGrid() {
            ctx.fillStyle = '#f9fafb';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            const totalItems = uploadedImages.length + 1;
            gridLayout = getGridLayout(totalItems);
            const { rows, cols } = gridLayout;
            const cellWidth = CANVAS_WIDTH / cols;
            const cellHeight = CANVAS_HEIGHT / rows;
            
            const text1 = textLine1Input.value.trim() || '';
            const text2 = checkboxLine2.checked ? 'ÊãâÁ∑öÈêµÂ°î‰øùÈ§ä' : (textLine2Input.value.trim() || '');
            
            let dateText = '';
            if (checkboxLine3.checked) {
                const today = new Date();
                const year = today.getFullYear();
                const month = (today.getMonth() + 1).toString().padStart(2, '0');
                const day = today.getDate().toString().padStart(2, '0');
                dateText = `${year}/${month}/${day}`;
            } else {
                dateText = datePicker.value ? datePicker.value.replace(/-/g, '/') : '';
            }
            const text3 = `${dateText} ÂÆåÊàê`;
            const textContent = `${text1}\n${text2}\n${text3}`;

            const allItems = [...uploadedImages];
            const finalTextCellPosition = Math.min(textCellPosition, allItems.length);
            allItems.splice(finalTextCellPosition, 0, { isText: true, content: textContent });
            
            for (let i = 0; i < allItems.length; i++) {
                const x = (i % cols) * cellWidth;
                const y = Math.floor(i / cols) * cellHeight;
                const item = allItems[i];

                if (item.isText) {
                    drawTextCell(item.content, x, y, cellWidth, cellHeight);
                } else if (item.image) {
                    drawImageWithBorder(item, x, y, cellWidth, cellHeight);
                } else {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(x, y, cellWidth, cellHeight);
                    
                    ctx.fillStyle = '#e5e7eb';
                    drawRoundedRect(x + BORDER_WIDTH, y + BORDER_WIDTH, cellWidth - BORDER_WIDTH * 2, cellHeight - BORDER_WIDTH * 2, BORDER_RADIUS / 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#9ca3af';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.font = '24px Arial, sans-serif';
                    ctx.fillText('ËºâÂÖ•Â§±Êïó', x + cellWidth / 2, y + cellHeight / 2);
                }
            }
        }

        function renderPreview() {
            previewContainer.innerHTML = '';
            uploadedImages.forEach((imgData, index) => {
                const container = document.createElement('div');
                container.className = 'relative preview-image-container';

                const img = document.createElement('img');
                img.src = imgData.url;
                img.className = 'w-16 h-16 rounded-md object-cover border border-gray-300';
                
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'delete-btn';
                deleteBtn.innerHTML = '&times;';
                deleteBtn.dataset.index = index;

                container.appendChild(img);
                container.appendChild(deleteBtn);
                previewContainer.appendChild(container);
            });
            drawGrid();
        }

        async function processFile(file) {
            return new Promise(resolve => {
                const url = URL.createObjectURL(file);
                const img = new Image();
                img.onload = () => {
                    resolve({
                        file,
                        url,
                        image: img,
                        offsetX: 0,
                        offsetY: 0
                    });
                };
                img.onerror = () => {
                    URL.revokeObjectURL(url);
                    resolve(null);
                };
                img.src = url;
            });
        }

        imageUpload.addEventListener('change', async (e) => {
            const files = Array.from(e.target.files).slice(0, 8 - uploadedImages.length);
            for (const file of files) {
                const imageData = await processFile(file);
                if (imageData) {
                    uploadedImages.push(imageData);
                }
            }
            renderPreview();
        });

        previewContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('delete-btn')) {
                const index = parseInt(e.target.dataset.index, 10);
                if (!isNaN(index)) {
                    URL.revokeObjectURL(uploadedImages[index].url);
                    uploadedImages.splice(index, 1);
                    renderPreview();
                }
            }
        });

        textPositionRadios.forEach(radio => {
            radio.addEventListener('change', (e) => {
                textCellPosition = parseInt(e.target.value, 10);
                drawGrid();
            });
        });

        textLine1Input.addEventListener('input', drawGrid);
        textLine2Input.addEventListener('input', drawGrid);
        datePicker.addEventListener('change', drawGrid);
        checkboxLine2.addEventListener('change', () => {
            textLine2Input.disabled = checkboxLine2.checked;
            if (checkboxLine2.checked) textLine2Input.value = '';
            drawGrid();
        });
        checkboxLine3.addEventListener('change', () => {
            datePicker.disabled = checkboxLine3.checked;
            if (checkboxLine3.checked) datePicker.value = '';
            drawGrid();
        });

        pasteButton.addEventListener('click', async () => {
            try {
                const text = await navigator.clipboard.readText();
                textLine1Input.value = text;
                drawGrid();
            } catch (err) {
                console.error('ÁÑ°Ê≥ïË≤º‰∏äÊñáÂ≠ó:', err);
            }
        });

        exportButton.addEventListener('click', () => {
            drawGrid().then(() => {
                canvas.toBlob(function(blob) {
                    if (blob === null) {
                        console.error('ÁÑ°Ê≥ïÂª∫Á´ã Blob„ÄÇ');
                        return;
                    }
                    const link = document.createElement('a');
                    link.download = '‰πùÂÆÆÊ†º.png';
                    link.href = URL.createObjectURL(blob);
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(link.href);
                }, 'image/png');
            });
        });

        function getCanvasMousePos(event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let x, y;
            if (event.touches) {
                x = (event.touches[0].clientX - rect.left) * scaleX;
                y = (event.touches[0].clientY - rect.top) * scaleY;
            } else {
                x = (event.clientX - rect.left) * scaleX;
                y = (event.clientY - rect.top) * scaleY;
            }
            return { x, y };
        }

        canvas.addEventListener('mousedown', (e) => handleDragStart(e));
        canvas.addEventListener('touchstart', (e) => handleDragStart(e));
        canvas.addEventListener('mousemove', (e) => handleDragMove(e));
        canvas.addEventListener('touchmove', (e) => handleDragMove(e));
        canvas.addEventListener('mouseup', handleDragEnd);
        canvas.addEventListener('touchend', handleDragEnd);
        canvas.addEventListener('mouseleave', handleDragEnd);

        function handleDragStart(e) {
            e.preventDefault();
            const { x, y } = getCanvasMousePos(e);
            const { rows, cols } = gridLayout;
            const cellWidth = CANVAS_WIDTH / cols;
            const cellHeight = CANVAS_HEIGHT / rows;
            
            const col = Math.floor(x / cellWidth);
            const row = Math.floor(y / cellHeight);
            const index = row * cols + col;

            const allItems = [...uploadedImages];
            const finalTextCellPosition = Math.min(textCellPosition, allItems.length);
            allItems.splice(finalTextCellPosition, 0, { isText: true });

            if (index < allItems.length && !allItems[index].isText) {
                isDragging = true;
                
                draggedItemIndex = index;
                if (draggedItemIndex > finalTextCellPosition) {
                    draggedItemIndex--;
                }
                
                lastX = x;
                lastY = y;
            }
        }

        function handleDragMove(e) {
            if (!isDragging || draggedItemIndex === -1) return;
            e.preventDefault();
            const { x, y } = getCanvasMousePos(e);

            const dx = x - lastX;
            const dy = y - lastY;

            const { rows, cols } = gridLayout;
            const cellWidth = CANVAS_WIDTH / cols;
            const cellHeight = CANVAS_HEIGHT / rows;

            const imageData = uploadedImages[draggedItemIndex];
            if (imageData && imageData.image) {
                const innerWidth = cellWidth - BORDER_WIDTH * 2;
                const innerHeight = cellHeight - BORDER_WIDTH * 2;
                const imageAspectRatio = imageData.image.width / imageData.image.height;
                const cellAspectRatio = innerWidth / innerHeight;

                const scaleFactor = imageAspectRatio > cellAspectRatio ? imageData.image.width / innerWidth : imageData.image.height / innerHeight;
                
                imageData.offsetX -= dx * scaleFactor;
                imageData.offsetY -= dy * scaleFactor;

                if (imageAspectRatio > cellAspectRatio) {
                    const maxOffset = (imageData.image.width - imageData.image.height * cellAspectRatio) / 2;
                    imageData.offsetX = Math.max(-maxOffset, Math.min(maxOffset, imageData.offsetX));
                } else {
                    const maxOffset = (imageData.image.height - imageData.image.width / cellAspectRatio) / 2;
                    imageData.offsetY = Math.max(-maxOffset, Math.min(maxOffset, imageData.offsetY));
                }

                drawGrid();
            }

            lastX = x;
            lastY = y;
        }

        function handleDragEnd() {
            isDragging = false;
            draggedItemIndex = -1;
        }

        drawGrid();
    </script>
</body>
</html>


